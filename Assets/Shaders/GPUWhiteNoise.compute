#define blockWidth 32
#define blockHeight 16
#define noiseregionsize 100

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel GPUWhiteNoise

// ==================================================
// ==================================================

// we parroting these
// https://www.shadertoy.com/view/4djSRW
// https://www.shadertoy.com/view/4dS3Wd

// Precision-adjusted variations of https://www.shadertoy.com/view/4djSRW
float hash(float p, float s) {
    p += s;
    p = frac(p * 0.011);
    p *= p + 7.5;
    p *= p + p;
    return frac(p);
}
float hash(float2 p) {
    float3 p3 = frac(float3(p.xyx) * 0.13);
    p3 += dot(p3, p3.yzx + 3.333);
    return frac((p3.x + p3.y) * p3.z);
}
float hash(float2 p, float s) {
    p+=float2(s%noiseregionsize,s/noiseregionsize);
    float3 p3 = frac(float3(p.xyx) * 0.13);
    p3 += dot(p3, p3.yzx + 3.333);
    return frac((p3.x + p3.y) * p3.z);
}

float noise(float x) {
    float i = floor(x);
    float f = frac(x);
    float u = f * f * (3.0 - 2.0 * f);
    return lerp(hash(i), hash(i + 1.0), u);
}
float noise(float x, float s) {
    x*=(s==0)?1:s;
    float i = floor(x);
    float f = frac(x);
    float u = f * f * (3.0 - 2.0 * f);
    return lerp(hash(i), hash(i + 1.0), u);
}

// ==================================================
// ==================================================


RWTexture2D<float4> Result;
int textureWidth;
int textureHeight;
int seed;

[numthreads(blockWidth,blockHeight,1)]
void GPUWhiteNoise (uint3 id : SV_DispatchThreadID)
{
    float2 texel = float2( id.x, id.y);
    // float2 uv = float2( ((texel.x)/(textureWidth)), ((texel.y)/(textureHeight)) );
    float seedNoNearZero = (seed < 0)? ((seed > -2.0)?-2.0:seed) : ((seed < 2.0)?2.0:seed);
    float noiseVal = noise(hash(texel,seedNoNearZero),seedNoNearZero);
    // float noiseVal = hash(texel, seed);
    Result[id.xy] = float4(noiseVal, noiseVal, noiseVal, 1.0f);
}
